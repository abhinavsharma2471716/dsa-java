You are given a string s and an integer k.

First, you are allowed to change at most one index in s to another lowercase English letter.

After that, do the following partitioning operation until s is empty:

Choose the longest prefix of s containing at most k distinct characters.
Delete the prefix from s and increase the number of partitions by one. The remaining characters (if any) in s maintain their initial order.
Return an integer denoting the maximum number of resulting partitions after the operations by optimally choosing at most one index to change.

 

Example 1:

Input: s = "accca", k = 2

Output: 3

Explanation:

The optimal way is to change s[2] to something other than a and c, for example, b. then it becomes "acbca".

Then we perform the operations:

The longest prefix containing at most 2 distinct characters is "ac", we remove it and s becomes "bca".
Now The longest prefix containing at most 2 distinct characters is "bc", so we remove it and s becomes "a".
Finally, we remove "a" and s becomes empty, so the procedure ends.
Doing the operations, the string is divided into 3 partitions, so the answer is 3.

Example 2:

Input: s = "aabaab", k = 3

Output: 1

Explanation:

Initially s contains 2 distinct characters, so whichever character we change, it will contain at most 3 distinct characters, so the longest prefix with at most 3 distinct characters would always be all of it, therefore the answer is 1.

Example 3:

Input: s = "xxyz", k = 1

Output: 4

Explanation:

The optimal way is to change s[0] or s[1] to something other than characters in s, for example, to change s[0] to w.

Then s becomes "wxyz", which consists of 4 distinct characters, so as k is 1, it will divide into 4 partitions.

 

Constraints:

1 <= s.length <= 104
s consists only of lowercase English letters.
1 <= k <= 26


Code : //O(n)


class Solution {

    public int maxPartitionsAfterOperations(String s, int k) {
        int n = s.length();

        // left[i] = {numPartitionsTillHere, bitmaskOfDistinct, countOfDistinct}
        int[][] left = new int[n][3];
        // right[i] = same as above but from the right side
        int[][] right = new int[n][3];

        /*
         * Step 1: Build prefix partition info
         * ----------------------------------
         * As we move left → right, we keep track of how many partitions have been formed,
         * the bitmask of characters in the current segment, and how many distinct chars
         * are in this ongoing segment.
         */
        int partitions = 0;
        int mask = 0;     // bitmask of current segment’s characters
        int distinct = 0; // number of distinct chars in current segment

        for (int i = 0; i < n - 1; i++) {
            int bit = 1 << (s.charAt(i) - 'a');
            // if new character for this segment
            if ((mask & bit) == 0) {
                distinct++;
                // if within k distinct limit, keep extending
                if (distinct <= k) {
                    mask |= bit;
                } else {
                    // exceeded k, start a new partition
                    partitions++;
                    mask = bit;
                    distinct = 1;
                }
            }
            // store state at i+1
            left[i + 1][0] = partitions;
            left[i + 1][1] = mask;
            left[i + 1][2] = distinct;
        }

        /*
         * Step 2: Build suffix partition info
         * -----------------------------------
         * Similar logic, but traverse right → left.
         */
        partitions = 0;
        mask = 0;
        distinct = 0;

        for (int i = n - 1; i > 0; i--) {
            int bit = 1 << (s.charAt(i) - 'a');
            if ((mask & bit) == 0) {
                distinct++;
                if (distinct <= k) {
                    mask |= bit;
                } else {
                    partitions++;
                    mask = bit;
                    distinct = 1;
                }
            }
            right[i - 1][0] = partitions;
            right[i - 1][1] = mask;
            right[i - 1][2] = distinct;
        }

        /*
         * Step 3: Combine prefix + suffix information
         * -------------------------------------------
         * Now we consider changing s[i] (or not) and estimate the total partitions.
         * We merge info from left[i] (prefix) and right[i] (suffix) to see how many
         * partitions can be formed after the optimal single character change.
         */
        int maxPartitions = 0;

        for (int i = 0; i < n; i++) {
            // basic segments from left + right sides
            int total = left[i][0] + right[i][0] + 2;

            // combined mask and distinct count from both sides
            int combinedMask = left[i][1] | right[i][1];
            int combinedDistinct = Integer.bitCount(combinedMask);

            /*
             * Now adjust total partitions based on the possibility of changing s[i]:
             * - If both sides already have k distinct chars, and combined < 26,
             *   changing s[i] could create an extra partition (+1)
             * - Otherwise, if combined distincts fit within k after one more char,
             *   we might merge one partition (-1)
             */
            if (left[i][2] == k && right[i][2] == k && combinedDistinct < 26) {
                total++;
            } else if (Math.min(combinedDistinct + 1, 26) <= k) {
                total--;
            }

            maxPartitions = Math.max(maxPartitions, total);
        }

        return maxPartitions;
    }
}
