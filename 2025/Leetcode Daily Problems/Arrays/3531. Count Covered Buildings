You are given a positive integer n, representing an n x n city. You are also given a 2D grid buildings, where buildings[i] = [x, y] denotes a unique building located at coordinates [x, y].

A building is covered if there is at least one building in all four directions: left, right, above, and below.

Return the number of covered buildings.

 

Example 1:



Input: n = 3, buildings = [[1,2],[2,2],[3,2],[2,1],[2,3]]

Output: 1

Explanation:

Only building [2,2] is covered as it has at least one building:
above ([1,2])
below ([3,2])
left ([2,1])
right ([2,3])
Thus, the count of covered buildings is 1.
Example 2:



Input: n = 3, buildings = [[1,1],[1,2],[2,1],[2,2]]

Output: 0

Explanation:

No building has at least one building in all four directions.
Example 3:



Input: n = 5, buildings = [[1,3],[3,2],[3,3],[3,5],[5,3]]

Output: 1

Explanation:

Only building [3,3] is covered as it has at least one building:
above ([1,3])
below ([5,3])
left ([3,2])
right ([3,5])
Thus, the count of covered buildings is 1.
 

Constraints:

2 <= n <= 10^5
1 <= buildings.length <= 10^5 
buildings[i] = [x, y]
1 <= x, y <= n
All coordinates of buildings are unique.


Code:

class Solution {
    public int countCoveredBuildings(int n, int[][] buildings) {
        int[] xLeft = new int[n + 1]; //tracks the leftMost x  for each y
        int[] xRight = new int[n + 1]; //tracks the rightMost x  for each y
        int[] yLeft = new int[n + 1]; //tracks the leftMost y  for each x //upper
        int[] yRight = new int[n + 1]; //tracks the rightMost y  for each x //lower
        int total = buildings.length;

        for (int i = 1; i <= n; i++) {
            xRight[i] = 0;
            xLeft[i] = n + 1;
            yRight[i] = 0;
            yLeft[i] = n + 1;
        }

        for (int[] building : buildings) {
            int x = building[0];
            int y = building[1];
            xLeft[y] = Math.min(xLeft[y], x); // update the left boundary for y
            xRight[y] = Math.max(xRight[y], x); // update the right boundary for y
            yLeft[x] = Math.min(yLeft[x], y); // update the left boundary for x
            yRight[x] = Math.max(yRight[x], y); // update the right boundary for x
        }

        int result =total;
        for(int[] building : buildings){
            int x = building[0];
            int y = building[1];
            if(x > xLeft[y] && x < xRight[y] && y > yLeft[x]  && y <  yRight[x] ){
                continue;
            }else{
                result -= 1;
            }
        }
    return result;
    }
}
