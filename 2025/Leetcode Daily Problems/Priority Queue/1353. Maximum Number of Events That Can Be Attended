You are given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi.

You can attend an event i at any day d where startTimei <= d <= endTimei. You can only attend one event at any time d.

Return the maximum number of events you can attend.

 

Example 1:


Input: events = [[1,2],[2,3],[3,4]]
Output: 3
Explanation: You can attend all the three events.
One way to attend them all is as shown.
Attend the first event on day 1.
Attend the second event on day 2.
Attend the third event on day 3.
Example 2:

Input: events= [[1,2],[2,3],[3,4],[1,2]]
Output: 4
 

Constraints:

1 <= events.length <= 10^5
events[i].length == 2
1 <= startDayi <= endDayi <= 10^5


Code :

Let n be the number of meetings in the given array events, and let T be the maximum value of any end time in events.

Time complexity: O((T+n)logn).

Sorting the array events takes O(nlogn) time. After sorting, we iterate over each day from 1 to T, giving us T time points to process. For each day, we may add or remove meetings from the priority queue, which maintains at most n elements. Each insertion or deletion operation in the heap takes O(logn) time. Therefore, the total cost of heap operations across all days is O(Tlogn). Combining both steps, the overall time complexity becomes O((T+n)logn).



class Solution {
    public int maxEvents(int[][] events) {
        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));

        PriorityQueue<Integer> pq = new PriorityQueue<>();
        int i = 0, res = 0, n = events.length;
        int day = 1;

        while (i < n || !pq.isEmpty()) {
            // Add all events starting on this day
            while (i < n && events[i][0] == day) {
                pq.offer(events[i][1]);
                i++;
            }

            // Remove all events that have already ended
            while (!pq.isEmpty() && pq.peek() < day) {
                pq.poll();
            }

            // Attend the event that ends earliest
            if (!pq.isEmpty()) {
                pq.poll();
                res++;
            }

            day++;
        }

        return res;
    }
}

