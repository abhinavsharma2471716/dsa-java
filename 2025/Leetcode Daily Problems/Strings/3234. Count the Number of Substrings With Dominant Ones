You are given a binary string s.

Return the number of substrings with dominant ones.

A string has dominant ones if the number of ones in the string is greater than or equal to the square of the number of zeros in the string.

 

Example 1:

Input: s = "00011"

Output: 5

Explanation:

The substrings with dominant ones are shown in the table below.

i	j	s[i..j]	Number of Zeros	Number of Ones
3	3	1	0	1
4	4	1	0	1
2	3	01	1	1
3	4	11	0	2
2	4	011	1	2
Example 2:

Input: s = "101101"

Output: 16

Explanation:

The substrings with non-dominant ones are shown in the table below.

Since there are 21 substrings total and 5 of them have non-dominant ones, it follows that there are 16 substrings with dominant ones.

i	j	s[i..j]	Number of Zeros	Number of Ones
1	1	0	1	0
4	4	0	1	0
1	4	0110	2	2
0	4	10110	2	3
1	5	01101	2	3
 

Constraints:

1 <= s.length <= 4 * 10^4
s consists only of characters '0' and '1'.

Code: O(n*Math.sqrt(n))

class Solution {
    public int numberOfSubstrings(String s) {
        int n = s.length();
        int[] prefix = new int[n];
        prefix[0] = (s.charAt(0) == '1') ? 1 : 0;
        for (int i = 1; i < n; i++) {
            prefix[i] = prefix[i - 1] + (s.charAt(i) == '1' ? 1 : 0);
        }
        int count = 0;
        for (int left = 0; left < n; left++) {
            for (int right = left; right < n;  right++) {
                int ones = prefix[right] - (left > 0 ? prefix[left - 1] : 0);
                int zeros = (right - left + 1) - ones;
                int sq = zeros * zeros;
                if (sq > ones) {
                    int need = sq - ones;
                    right += need - 1;
                }
                else if (sq == ones) {
                    count++;
                }
                else {
                    count++;
                    int need = (int)Math.sqrt(ones) - zeros;
                    int jump = right + need;
                    if (jump >= n) {
                        count += (n - right - 1);
                        break;
                    } else {
                        count += need;
                    }
                    right = jump;
                }
            }
        }
        return count;
    }
}
