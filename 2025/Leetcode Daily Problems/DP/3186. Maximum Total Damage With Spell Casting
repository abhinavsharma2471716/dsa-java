A magician has various spells.

You are given an array power, where each element represents the damage of a spell. Multiple spells can have the same damage value.

It is a known fact that if a magician decides to cast a spell with a damage of power[i], they cannot cast any spell with a damage of power[i] - 2, power[i] - 1, power[i] + 1, or power[i] + 2.

Each spell can be cast only once.

Return the maximum possible total damage that a magician can cast.

 

Example 1:

Input: power = [1,1,3,4]

Output: 6

Explanation:

The maximum possible damage of 6 is produced by casting spells 0, 1, 3 with damage 1, 1, 4.

Example 2:

Input: power = [7,1,6,6]

Output: 13

Explanation:

The maximum possible damage of 13 is produced by casting spells 1, 2, 3 with damage 1, 6, 6.

 

Constraints:

1 <= power.length <= 10^5
1 <= power[i] <= 10^9

Code : //O(m +nlogn + n*3)

class Solution {
    public long maximumTotalDamage(int[] power) {
        Map<Integer, Long> damageMap = new HashMap<>();
        for (int p : power) {
            damageMap.put(p, damageMap.getOrDefault(p, 0L) + p);
        }

        List<Integer> keys = new ArrayList<>(damageMap.keySet());
        Collections.sort(keys);

        int n = keys.size();
        long[] dp = new long[n];
        dp[0] = damageMap.get(keys.get(0));

        for (int i = 1; i < n; i++) {
            long take = damageMap.get(keys.get(i));
            int j = i - 1;
            // find last compatible damage (difference >= 3)
            while (j >= 0 && keys.get(i) - keys.get(j) < 3) j--;
            if (j >= 0) take += dp[j];
            long notTake = dp[i - 1];
            dp[i] = Math.max(take, notTake);
        }

        return dp[n - 1];
    }
}
