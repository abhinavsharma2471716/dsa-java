You are given an integer array nums and a positive integer k.
A subsequence sub of nums with length x is called valid if it satisfies:

(sub[0] + sub[1]) % k == (sub[1] + sub[2]) % k == ... == (sub[x - 2] + sub[x - 1]) % k.
Return the length of the longest valid subsequence of nums.
 

Example 1:

Input: nums = [1,2,3,4,5], k = 2

Output: 5

Explanation:

The longest valid subsequence is [1, 2, 3, 4, 5].

Example 2:

Input: nums = [1,4,2,3,1,4], k = 3

Output: 4

Explanation:

The longest valid subsequence is [1, 4, 1, 4].

 

Constraints:

2 <= nums.length <= 103
1 <= nums[i] <= 107
1 <= k <= 103

Code :

class Solution {

    public int maximumLength(int[] nums, int k) {
        // dp[i][j] represents the length of the longest valid subsequence
        // where the last two numbers have (i + j) % k == some constant
        int[][] dp = new int[k][k];
        int res = 0;

        for (int num : nums) {
            int currentMod = num % k;

            for (int prevMod = 0; prevMod < k; prevMod++) {
                // We update dp[prevMod][currentMod] by extending
                // the sequence ending in (currentMod, prevMod)
                dp[prevMod][currentMod] = dp[currentMod][prevMod] + 1;

                // Update result with the longest length found so far
                res = Math.max(res, dp[prevMod][currentMod]);
            }
        }

        return res;
    }
}
