You have two soups, A and B, each starting with n mL. On every turn, one of the following four serving operations is chosen at random, each with probability 0.25 independent of all previous turns:

pour 100 mL from type A and 0 mL from type B
pour 75 mL from type A and 25 mL from type B
pour 50 mL from type A and 50 mL from type B
pour 25 mL from type A and 75 mL from type B
Note:

There is no operation that pours 0 mL from A and 100 mL from B.
The amounts from A and B are poured simultaneously during the turn.
If an operation asks you to pour more than you have left of a soup, pour all that remains of that soup.
The process stops immediately after any turn in which one of the soups is used up.

Return the probability that A is used up before B, plus half the probability that both soups are used up in the same turn. Answers within 10-5 of the actual answer will be accepted.

 

Example 1:

Input: n = 50
Output: 0.62500
Explanation: 
If we perform either of the first two serving operations, soup A will become empty first.
If we perform the third operation, A and B will become empty at the same time.
If we perform the fourth operation, B will become empty first.
So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.
Example 2:

Input: n = 100
Output: 0.71875
Explanation: 
If we perform the first serving operation, soup A will become empty first.
If we perform the second serving operations, A will become empty on performing operation [1, 2, 3], and both A and B become empty on performing operation 4.
If we perform the third operation, A will become empty on performing operation [1, 2], and both A and B become empty on performing operation 3.
If we perform the fourth operation, A will become empty on performing operation 1, and both A and B become empty on performing operation 2.
So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.71875.
 

Constraints:

0 <= n <= 10^9


Code:


Approach 1:

class Solution {
    public double soupServings(int n) {
        // Convert milliliters to units of 25 mL
        // Because every serving amount is a multiple of 25 mL
        int m = (int) Math.ceil(n / 25.0);
        // Memoization table: dp[a][b] stored as a nested HashMap
        // dp[a][b] = probability result starting with a units of soup A and b units of soup B
        Map<Integer, Map<Integer, Double>> dp = new HashMap<>();
        // Dynamic cutoff search:
        // Instead of hardcoding 4800, we find the smallest k such that
        // the probability with (k, k) soups is already within 1e-5 of 1
        for (int k = 1; k <= m; k++) {
            if (calculateDP(k, k, dp) > 1 - 1e-5) {
                // For any larger m, probability will be even closer to 1
                return 1.0;
            }
        }
        // If cutoff not reached, compute the actual probability for (m, m)
        return calculateDP(m, m, dp);
    }

    private double calculateDP(int a, int b, Map<Integer, Map<Integer, Double>> dp) {
        // Base cases:
        if (a <= 0 && b <= 0) return 0.5; // both empty at same time
        if (a <= 0) return 1.0;           // A empty first
        if (b <= 0) return 0.0;           // B empty first
        // Check memo
        if (dp.containsKey(a) && dp.get(a).containsKey(b)) {
            return dp.get(a).get(b);
        }
        // Recursive transitions:
        // Each serving option is equally likely (probability 0.25)
        double result =
            (calculateDP(a - 4, b, dp)   // Serve 100 mL from A, 0 mL from B
           + calculateDP(a - 3, b - 1, dp) // Serve 75 mL from A, 25 mL from B
           + calculateDP(a - 2, b - 2, dp) // Serve 50 mL from A, 50 mL from B
           + calculateDP(a - 1, b - 3, dp) // Serve 25 mL from A, 75 mL from B
            ) / 4.0;
        // Store in memo
        dp.computeIfAbsent(a, k -> new HashMap<>()).put(b, result);
        return result;
    }
}



Approach 2:


class Solution {
    public double soupServings(int n) {
        // For large n, probability approaches 1
        if (n >= 4800) return 1.0;

        int m = (n + 24) / 25; // scale down to units of 25 mL
        Double[][] memo = new Double[m + 1][m + 1];
        return dfs(m, m, memo);
    }

    private double dfs(int a, int b, Double[][] memo) {
        if (a <= 0 && b <= 0) return 0.5;
        if (a <= 0) return 1.0;
        if (b <= 0) return 0.0;
        if (memo[a][b] != null) return memo[a][b];

        memo[a][b] = 0.25 * (
            dfs(a - 4, b, memo) +
            dfs(a - 3, b - 1, memo) +
            dfs(a - 2, b - 2, memo) +
            dfs(a - 1, b - 3, memo)
        );
        return memo[a][b];
    }
}
