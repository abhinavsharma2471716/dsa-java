You are given an integer eventTime denoting the duration of an event, where the event occurs from time t = 0 to time t = eventTime.

You are also given two integer arrays startTime and endTime, each of length n. These represent the start and end time of n non-overlapping meetings, where the ith meeting occurs during the time [startTime[i], endTime[i]].

You can reschedule at most k meetings by moving their start time while maintaining the same duration, to maximize the longest continuous period of free time during the event.

The relative order of all the meetings should stay the same and they should remain non-overlapping.

Return the maximum amount of free time possible after rearranging the meetings.

Note that the meetings can not be rescheduled to a time outside the event.

 

Example 1:

Input: eventTime = 5, k = 1, startTime = [1,3], endTime = [2,5]

Output: 2

Explanation:



Reschedule the meeting at [1, 2] to [2, 3], leaving no meetings during the time [0, 2].

Example 2:

Input: eventTime = 10, k = 1, startTime = [0,2,9], endTime = [1,4,10]

Output: 6

Explanation:



Reschedule the meeting at [2, 4] to [1, 3], leaving no meetings during the time [3, 9].

Example 3:

Input: eventTime = 5, k = 2, startTime = [0,1,2,3,4], endTime = [1,2,3,4,5]

Output: 0

Explanation:

There is no time during the event not occupied by meetings.

 

Constraints:

1 <= eventTime <= 109
n == startTime.length == endTime.length
2 <= n <= 105
1 <= k <= n
0 <= startTime[i] < endTime[i] <= eventTime
endTime[i] <= startTime[i + 1] where i lies in the range [0, n - 2].

Code :

Approach 1: Greedy + Prefix Sum

class Solution {
    public int maxFreeTime(int eventTime, int k, int[] startTime, int[] endTime) {
        int n = startTime.length;
        int maxFreeTime = 0;

        // Step 1: Compute prefix sum of durations of meetings
        int[] prefixDuration = new int[n + 1];
        for (int i = 0; i < n; i++) {
            int duration = endTime[i] - startTime[i];
            prefixDuration[i + 1] = prefixDuration[i] + duration;
        }

        // Step 2: Slide a window of k adjacent meetings
        for (int i = k - 1; i < n; i++) {
            // Calculate the total duration of the k meetings: from index (i - k + 1) to i
            int totalMeetingDuration = prefixDuration[i + 1] - prefixDuration[i - k + 1];

            // Determine the start of the merged free interval (left bound)
            int left = (i == k - 1) ? 0 : endTime[i - k];

            // Determine the end of the merged free interval (right bound)
            int right = (i == n - 1) ? eventTime : startTime[i + 1];

            // Calculate the total length of the free interval after removing the meetings
            int freeTime = right - left - totalMeetingDuration;

            // Update the maximum free time found
            maxFreeTime = Math.max(maxFreeTime, freeTime);
        }

        return maxFreeTime;
    }
}


Approach 2: Greedy + Sliding Window


class Solution {
    public int maxFreeTime(int eventTime, int k, int[] startTime, int[] endTime) {
        int n = startTime.length;
        int maxFreeTime = 0;
        // Track the total duration of the current sliding window of k meetings
        int currentWindowDuration = 0;
        for (int right = 0; right < n; right++) {
            // Add the current meeting's duration to the window
            int duration = endTime[right] - startTime[right];
            currentWindowDuration += duration;
            // Only start computing free time once we've filled a window of size k
            if (right >= k - 1) {
                int leftIndex = right - k + 1;
                // Determine the left bound of the potential merged free interval
                int leftBound = (leftIndex == 0) ? 0 : endTime[leftIndex - 1];
                // Determine the right bound of the potential merged free interval
                int rightBound = (right == n - 1) ? eventTime : startTime[right + 1];
                // Compute the total free time after shifting these k meetings
                int mergedFreeTime = rightBound - leftBound - currentWindowDuration;
                // Update the max free time found so far
                maxFreeTime = Math.max(maxFreeTime, mergedFreeTime);
                // Slide the window: remove the leftmost meeting's duration
                int leftDuration = endTime[leftIndex] - startTime[leftIndex];
                currentWindowDuration -= leftDuration;
            }
        }
        return maxFreeTime;
    }
}
