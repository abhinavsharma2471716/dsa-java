Design a data structure that can efficiently manage data packets in a network router. Each data packet consists of the following attributes:

source: A unique identifier for the machine that generated the packet.
destination: A unique identifier for the target machine.
timestamp: The time at which the packet arrived at the router.
Implement the Router class:

Router(int memoryLimit): Initializes the Router object with a fixed memory limit.

memoryLimit is the maximum number of packets the router can store at any given time.
If adding a new packet would exceed this limit, the oldest packet must be removed to free up space.
bool addPacket(int source, int destination, int timestamp): Adds a packet with the given attributes to the router.

A packet is considered a duplicate if another packet with the same source, destination, and timestamp already exists in the router.
Return true if the packet is successfully added (i.e., it is not a duplicate); otherwise return false.
int[] forwardPacket(): Forwards the next packet in FIFO (First In First Out) order.

Remove the packet from storage.
Return the packet as an array [source, destination, timestamp].
If there are no packets to forward, return an empty array.
int getCount(int destination, int startTime, int endTime):

Returns the number of packets currently stored in the router (i.e., not yet forwarded) that have the specified destination and have timestamps in the inclusive range [startTime, endTime].
Note that queries for addPacket will be made in increasing order of timestamp.

 

Example 1:

Input:
["Router", "addPacket", "addPacket", "addPacket", "addPacket", "addPacket", "forwardPacket", "addPacket", "getCount"]
[[3], [1, 4, 90], [2, 5, 90], [1, 4, 90], [3, 5, 95], [4, 5, 105], [], [5, 2, 110], [5, 100, 110]]

Output:
[null, true, true, false, true, true, [2, 5, 90], true, 1]

Explanation

Router router = new Router(3); // Initialize Router with memoryLimit of 3.
router.addPacket(1, 4, 90); // Packet is added. Return True.
router.addPacket(2, 5, 90); // Packet is added. Return True.
router.addPacket(1, 4, 90); // This is a duplicate packet. Return False.
router.addPacket(3, 5, 95); // Packet is added. Return True
router.addPacket(4, 5, 105); // Packet is added, [1, 4, 90] is removed as number of packets exceeds memoryLimit. Return True.
router.forwardPacket(); // Return [2, 5, 90] and remove it from router.
router.addPacket(5, 2, 110); // Packet is added. Return True.
router.getCount(5, 100, 110); // The only packet with destination 5 and timestamp in the inclusive range [100, 110] is [4, 5, 105]. Return 1.
Example 2:

Input:
["Router", "addPacket", "forwardPacket", "forwardPacket"]
[[2], [7, 4, 90], [], []]

Output:
[null, true, [7, 4, 90], []]

Explanation

Router router = new Router(2); // Initialize Router with memoryLimit of 2.
router.addPacket(7, 4, 90); // Return True.
router.forwardPacket(); // Return [7, 4, 90].
router.forwardPacket(); // There are no packets left, return [].
 

Constraints:

2 <= memoryLimit <= 105
1 <= source, destination <= 2 * 105
1 <= timestamp <= 109
1 <= startTime <= endTime <= 109
At most 105 calls will be made to addPacket, forwardPacket, and getCount methods altogether.
queries for addPacket will be made in increasing order of timestamp.

Code :

class Router {
    int limit;
    Deque<DataPacket> queue;
    Set<String> seen; // for duplicates
    Map<Integer, ArrayList<Integer>> destTimestamps; // destination -> sorted timestamps

    public Router(int memoryLimit) {
        queue = new LinkedList<>();
        seen = new HashSet<>();
        destTimestamps = new HashMap<>();
        limit = memoryLimit;
    }

    class DataPacket {
        int source, destination, timestamp;
        public DataPacket(int s, int d, int t) {
            source = s;
            destination = d;
            timestamp = t;
        }
    }

    private String key(int s, int d, int t) {
        return s + "#" + d + "#" + t;
    }

    public boolean addPacket(int source, int destination, int timestamp) {
        String k = key(source, destination, timestamp);
        if (seen.contains(k)) return false;

        if (queue.size() == limit) { // remove oldest
            DataPacket removed = queue.pollFirst();
            if (removed != null) {
                seen.remove(key(removed.source, removed.destination, removed.timestamp));
                ArrayList<Integer> tsList = destTimestamps.get(removed.destination);
                tsList.remove(0); // remove oldest timestamp
            }
        }

        DataPacket dp = new DataPacket(source, destination, timestamp);
        queue.addLast(dp);
        seen.add(k);

        destTimestamps.putIfAbsent(destination, new ArrayList<>());
        destTimestamps.get(destination).add(timestamp); // always appended, sorted
        return true;
    }

    public int[] forwardPacket() {
        if (queue.isEmpty()) return new int[0];

        DataPacket rem = queue.pollFirst();
        seen.remove(key(rem.source, rem.destination, rem.timestamp));

        ArrayList<Integer> tsList = destTimestamps.get(rem.destination);
        tsList.remove(0); // remove the oldest timestamp
        return new int[]{rem.source, rem.destination, rem.timestamp};
    }

    public int getCount(int destination, int startTime, int endTime) {
        if (!destTimestamps.containsKey(destination)) return 0;
        ArrayList<Integer> tsList = destTimestamps.get(destination);

        int l = lowerBound(tsList, startTime);
        int r = upperBound(tsList, endTime) - 1;
        return Math.max(0, r - l + 1);
    }

    // first index >= target
    private int lowerBound(ArrayList<Integer> list, int target) {
        int low = 0, high = list.size();
        while (low < high) {
            int mid = (low + high) / 2;
            if (list.get(mid) >= target) high = mid;
            else low = mid + 1;
        }
        return low;
    }

    // first index > target
    private int upperBound(ArrayList<Integer> list, int target) {
        int low = 0, high = list.size();
        while (low < high) {
            int mid = (low + high) / 2;
            if (list.get(mid) > target) high = mid;
            else low = mid + 1;
        }
        return low;
    }
}


Notes:

1️⃣ addPacket(int source, int destination, int timestamp)

Operations:

seen.contains(k) → O(1) average (HashSet lookup).

queue.size() == limit → O(1).

queue.pollFirst() → O(1) (LinkedList deque).

seen.remove(key(...)) → O(1).

tsList.remove(0) → O(n) because ArrayList.remove(0) shifts all elements. ✅ This is the bottleneck.

queue.addLast(dp) → O(1).

seen.add(k) → O(1).

tsList.add(timestamp) → O(1) amortized (append to ArrayList).

So overall:

Best case (no removal needed) → O(1)

Worst case (queue full, remove oldest timestamp from ArrayList) → O(m), where m = # of timestamps for that destination in the queue.

Bottleneck: tsList.remove(0) shifts elements.

2️⃣ forwardPacket()

Operations:

queue.pollFirst() → O(1)

seen.remove(key(...)) → O(1)

tsList.remove(0) → O(m) (same issue as above)

3️⃣ getCount(int destination, int startTime, int endTime)

Operations:

tsList lookup → O(1) (HashMap)

lowerBound(tsList, startTime) → O(log m)

upperBound(tsList, endTime) → O(log m)

So overall: O(log m), where m = # of timestamps for the destination.
