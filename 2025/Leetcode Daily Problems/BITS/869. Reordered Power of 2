You are given an integer n. We reorder the digits in any order (including the original order) such that the leading digit is not zero.

Return true if and only if we can do this so that the resulting number is a power of two.

 

Example 1:

Input: n = 1
Output: true
Example 2:

Input: n = 10
Output: false
 

Constraints:

1 <= n <= 10^9

Code:

Approach 1: //O(nlogn)


class Solution {
    public boolean reorderedPowerOf2(int n) {
        // Sort the digits of n to use as a reference
        char[] target = String.valueOf(n).toCharArray();
        Arrays.sort(target);

        // Check against all powers of 2 up to 2^30 (since 2^31 exceeds int range)
        for (int i = 0; i < 31; i++) {
            int num = 1 << i;
            char[] powerDigits = String.valueOf(num).toCharArray();
            Arrays.sort(powerDigits);
            
            if (Arrays.equals(target, powerDigits)) {
                return true;
            }
        }
        return false;
    }
}

Approach 2: //O(1)

class Solution {
    public boolean reorderedPowerOf2(int n) {
        int[] targetCount = digitCount(n);

        for (int i = 0; i < 31; i++) {
            int[] powerCount = digitCount(1 << i);
            if (matches(targetCount, powerCount)) {
                return true;
            }
        }
        return false;
    }

    // Count the frequency of each digit (0-9)
    private int[] digitCount(int num) {
        int[] count = new int[10];
        while (num > 0) {
            count[num % 10]++;
            num /= 10;
        }
        return count;
    }

    // Check if two digit frequency arrays are equal
    private boolean matches(int[] a, int[] b) {
        for (int i = 0; i < 10; i++) {
            if (a[i] != b[i]) return false;
        }
        return true;
    }
}
