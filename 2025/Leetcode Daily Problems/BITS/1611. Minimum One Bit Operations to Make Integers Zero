Given an integer n, you must transform it into 0 using the following operations any number of times:

Change the rightmost (0th) bit in the binary representation of n.
Change the ith bit in the binary representation of n if the (i-1)th bit is set to 1 and the (i-2)th through 0th bits are set to 0.
Return the minimum number of operations to transform n into 0.

 

Example 1:

Input: n = 3
Output: 2
Explanation: The binary representation of 3 is "11".
"11" -> "01" with the 2nd operation since the 0th bit is 1.
"01" -> "00" with the 1st operation.
Example 2:

Input: n = 6
Output: 4
Explanation: The binary representation of 6 is "110".
"110" -> "010" with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0.
"010" -> "011" with the 1st operation.
"011" -> "001" with the 2nd operation since the 0th bit is 1.
"001" -> "000" with the 1st operation.
 

Constraints:

0 <= n <= 109


Code : //O(1)

public class Solution {
    public int minimumOneBitOperations(int n) {
        // Base case
        if (n == 0) return 0;
        // Precompute function[i] = number of operations to flip the i-th bit alone
        long[] function = new long[32];
        function[0] = 1; // flipping the least significant bit needs 1 operation
        for (int i = 1; i < 32; i++) {
            function[i] = 2 * function[i - 1] + 1;
            // Pattern: 1, 3, 7, 15, 31, ... = (1 << (i + 1)) - 1
        }
        int result = 0;
        int sign = 1; // alternates between +1 and -1 for each bit set
        // Traverse bits from high (MSB) to low (LSB)
        for (int i = 30; i >= 0; i--) {
            // Check if i-th bit is set in n
            if ((n & (1 << i)) == 0) continue;

            // Add or subtract corresponding function[i]
            if (sign > 0) {
                result += function[i];
            } else {
                result -= function[i];
            }
            // Flip sign (since each set bit changes operation direction)
            sign *= -1;
        }
        return result;
    }
}
