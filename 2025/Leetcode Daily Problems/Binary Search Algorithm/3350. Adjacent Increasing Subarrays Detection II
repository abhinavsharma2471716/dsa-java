Given an array nums of n integers, your task is to find the maximum value of k for which there exist two adjacent subarrays of length k each, such that both subarrays are strictly increasing. Specifically, check if there are two subarrays of length k starting at indices a and b (a < b), where:

Both subarrays nums[a..a + k - 1] and nums[b..b + k - 1] are strictly increasing.
The subarrays must be adjacent, meaning b = a + k.
Return the maximum possible value of k.

A subarray is a contiguous non-empty sequence of elements within an array.

 

Example 1:

Input: nums = [2,5,7,8,9,2,3,4,3,1]

Output: 3

Explanation:

The subarray starting at index 2 is [7, 8, 9], which is strictly increasing.
The subarray starting at index 5 is [2, 3, 4], which is also strictly increasing.
These two subarrays are adjacent, and 3 is the maximum possible value of k for which two such adjacent strictly increasing subarrays exist.
Example 2:

Input: nums = [1,2,3,4,4,4,4,5,6,7]

Output: 2

Explanation:

The subarray starting at index 0 is [1, 2], which is strictly increasing.
The subarray starting at index 2 is [3, 4], which is also strictly increasing.
These two subarrays are adjacent, and 2 is the maximum possible value of k for which two such adjacent strictly increasing subarrays exist.
 

Constraints:

2 <= nums.length <= 2 * 10^5
-10^9 <= nums[i] <= 10^9

Code: Total time=O(n) (precomputation)+O(nlogn) (binary search checks)

class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        
        // Precompute the length of increasing sequences starting from each index
        int[] incLength = new int[n];
        incLength[n - 1] = 1;
        
        for (int i = n - 2; i >= 0; i--) {
            if (nums.get(i) < nums.get(i + 1)) {
                incLength[i] = incLength[i + 1] + 1;
            } else {
                incLength[i] = 1;
            }
        }
        
        // Binary search to find the maximum k
        int left = 1, right = n / 2;
        int result = 0;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (canFindAdjacentIncreasingSubarrays(incLength, mid)) {
                result = mid; // mid is a valid k, try for a larger k
                left = mid + 1;
            } else {
                right = mid - 1; // mid is too large, try for a smaller k
            }
        }

        return result;
    }

    // Optimized helper function using precomputed increasing lengths
    private boolean canFindAdjacentIncreasingSubarrays(int[] incLength, int k) {
        int n = incLength.length;
        
        // Check if there exists two adjacent subarrays of length k that are both strictly increasing
        for (int i = 0; i <= n - 2 * k; i++) {
            // Check if both the subarray starting at i and the one starting at i + k are increasing
            if (incLength[i] >= k && incLength[i + k] >= k) {
                return true;
            }
        }

        return false;
    }
}


