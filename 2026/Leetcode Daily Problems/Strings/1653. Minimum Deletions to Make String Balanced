You are given a string s consisting only of characters 'a' and 'b'â€‹â€‹â€‹â€‹.

You can delete any number of characters in s to make s balanced. s is balanced if there is no pair of indices (i,j) such that i < j and s[i] = 'b' and s[j]= 'a'.

Return the minimum number of deletions needed to make s balanced.

 

Example 1:

Input: s = "aababbab"
Output: 2
Explanation: You can either:
Delete the characters at 0-indexed positions 2 and 6 ("aababbab" -> "aaabbb"), or
Delete the characters at 0-indexed positions 3 and 6 ("aababbab" -> "aabbbb").
Example 2:

Input: s = "bbaaaaabb"
Output: 2
Explanation: The only solution is to delete the first two characters.
 

Constraints:

1 <= s.length <= 105
s[i] is 'a' or 'b'â€‹â€‹.
 


Code: //O(n)

class Solution {
    public int minimumDeletions(String s) {
        int n = s.length();
        int countB = 0, minDeletions = 0;
        
        // minDeletions variable represents dp[i]
        //dp[i] = the minimum number of deletions needed to make the substring s[0â€¦i] balanced
        //dp[i] = minimum deletions so far to keep all 'a' before 'b' up to index i
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == 'b') {
                countB++;
            } else {
                // s.charAt(i) == 'a'
                //// Two cases: remove 'a' or keep 'a'
                minDeletions = Math.min(minDeletions + 1, countB);
            }
        }

        return minDeletions;
    }
}



Extra:

You want the string to look like this:

aaaa...bbbb


So the only bad situation is:

an 'a' appearing after a 'b'

What you track while scanning

As you move left â†’ right:

countB â†’ how many 'b' youâ€™ve already seen

minDeletions â†’ minimum deletions needed so far to keep things valid

What happens at each character?
If you see 'b'

No issue.
'b' belongs on the right side anyway.
â†’ Just count it.

If you see 'a'

This is where the decision happens.

You have two options:

 Delete this 'a'
That costs 1 deletion
(total becomes minDeletions + 1)

 Keep this 'a'
Then all previous 'b' are wrong
So you must delete every 'b' seen so far
(cost = countB)

ðŸ‘‰ You simply choose the cheaper option.

minDeletions = min(delete_a, delete_all_previous_b);

