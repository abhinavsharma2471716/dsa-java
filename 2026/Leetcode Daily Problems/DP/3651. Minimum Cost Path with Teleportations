You are given a m x n 2D integer array grid and an integer k. You start at the top-left cell (0, 0) and your goal is to reach the bottom‐right cell (m - 1, n - 1).

There are two types of moves available:

Normal move: You can move right or down from your current cell (i, j), i.e. you can move to (i, j + 1) (right) or (i + 1, j) (down). The cost is the value of the destination cell.

Teleportation: You can teleport from any cell (i, j), to any cell (x, y) such that grid[x][y] <= grid[i][j]; the cost of this move is 0. You may teleport at most k times.

Return the minimum total cost to reach cell (m - 1, n - 1) from (0, 0).

 

Example 1:

Input: grid = [[1,3,3],[2,5,4],[4,3,5]], k = 2

Output: 7

Explanation:

Initially we are at (0, 0) and cost is 0.

Current Position	Move	New Position	Total Cost
(0, 0)	Move Down	(1, 0)	0 + 2 = 2
(1, 0)	Move Right	(1, 1)	2 + 5 = 7
(1, 1)	Teleport to (2, 2)	(2, 2)	7 + 0 = 7
The minimum cost to reach bottom-right cell is 7.

Example 2:

Input: grid = [[1,2],[2,3],[3,4]], k = 1

Output: 9

Explanation:

Initially we are at (0, 0) and cost is 0.

Current Position	Move	New Position	Total Cost
(0, 0)	Move Down	(1, 0)	0 + 2 = 2
(1, 0)	Move Right	(1, 1)	2 + 3 = 5
(1, 1)	Move Down	(2, 1)	5 + 4 = 9
The minimum cost to reach bottom-right cell is 9.

 

Constraints:

2 <= m, n <= 80
m == grid.length
n == grid[i].length
0 <= grid[i][j] <= 10^4
0 <= k <= 10
 


Code: O(mnlog(mn)+k⋅mn)

class Solution {

    public int minCost(int[][] grid, int k) {
        int m = grid.length, n = grid[0].length;

        // Collect all cells
        List<int[]> cells = new ArrayList<>();
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                cells.add(new int[]{r, c});
            }
        }

        // Sort cells by grid value
        cells.sort(Comparator.comparingInt(cell -> grid[cell[0]][cell[1]]));

        // DP cost array
        int[][] cost = new int[m][n];
        for (int[] row : cost) Arrays.fill(row, Integer.MAX_VALUE);

        // Perform k relaxations
        for (int step = 0; step <= k; step++) {

            // Relax costs for cells with equal values
            int prefixMin = Integer.MAX_VALUE;
            int start = 0;

            for (int i = 0; i < cells.size(); i++) {
                int r = cells.get(i)[0];
                int c = cells.get(i)[1];
                prefixMin = Math.min(prefixMin, cost[r][c]);

                boolean isLastInGroup =
                    i + 1 == cells.size() ||
                    grid[r][c] != grid[cells.get(i + 1)[0]][cells.get(i + 1)[1]];

                if (isLastInGroup) {
                    for (int j = start; j <= i; j++) {
                        int x = cells.get(j)[0];
                        int y = cells.get(j)[1];
                        cost[x][y] = prefixMin;
                    }
                    start = i + 1;
                }
            }

            // Standard DP from bottom-right
            for (int r = m - 1; r >= 0; r--) {
                for (int c = n - 1; c >= 0; c--) {

                    if (r == m - 1 && c == n - 1) {
                        cost[r][c] = 0;
                        continue;
                    }

                    if (r + 1 < m) {
                        cost[r][c] = Math.min(
                            cost[r][c],
                            cost[r + 1][c] + grid[r + 1][c]
                        );
                    }

                    if (c + 1 < n) {
                        cost[r][c] = Math.min(
                            cost[r][c],
                            cost[r][c + 1] + grid[r][c + 1]
                        );
                    }
                }
            }
        }

        return cost[0][0];
    }
}

